# Configuration
config:
  init:
    wizard:
      title: "Assistant de configuration Stud CLI"
      description: "Cela créera ou mettra à jour votre fichier de configuration à : %path%"
    language:
      title: "Configuration de la langue"
      prompt: "Sélectionnez votre langue"
    jira:
      title: "Configuration Jira"
      token_help: "Vous pouvez générer un jeton API ici : https://id.atlassian.com/manage-profile/security/api-tokens"
      url_prompt: "Entrez votre URL Jira"
      email_prompt: "Entrez votre adresse e-mail Jira"
      token_prompt: "Entrez votre jeton API Jira (laissez vide pour conserver l'existant)"
    git:
      title: "Configuration du fournisseur Git"
      description: "Ceci est requis pour la commande `stud submit` afin de créer des Pull Requests."
      token_help: "Vous pouvez générer un jeton ici : https://github.com/settings/tokens"
      auto_detect_note: "Note : Le propriétaire et le nom du dépôt seront automatiquement détectés depuis votre remote git."
      provider_prompt: "Sélectionnez votre fournisseur Git"
      token_prompt: "Entrez votre PAT du fournisseur Git (laissez vide pour conserver l'existant)"
    jira_transition:
      title: "Configuration de transition Jira"
      description: "Activer la transition automatique vers 'En cours' lors du démarrage d'un ticket."
      prompt: "Activer la transition automatique Jira vers 'En cours' ?"
    success: "Configuration enregistrée avec succès !"
    completion:
      title: "Configuration de l'auto-complétion du shell"
      prompt: "Nous avons détecté que vous utilisez '%shell%'. Souhaitez-vous configurer l'auto-complétion du shell ?"
      yes: "Oui"
      no: "Non"
      success_message: "✅ Parfait ! Pour terminer l'installation, exécutez cette commande :"
      bash_command: "echo 'eval \"$(stud completion bash)\"' >> ~/.bashrc"
      zsh_command: "echo 'eval \"$(stud completion zsh)\"' >> ~/.zshrc"
      reload_instruction: "Ensuite, redémarrez votre shell ou exécutez 'source ~/.%shellrc%'"
      skipped: "Configuration de l'auto-complétion du shell ignorée."
  error:
    not_found: "Fichier de configuration introuvable à : %path%\nVeuillez exécuter \"stud config:init\" pour en créer un."
    missing_jira_keys: "Votre fichier de configuration manque des clés Jira requises : %keys%\nVeuillez exécuter \"stud config:init\" à nouveau."
    missing_git_keys: "Votre fichier de configuration manque des clés du fournisseur Git requises : %keys%\nVeuillez exécuter \"stud config:init\" à nouveau."

# Item Start Handler
item:
  start:
    section: "Démarrage du travail sur %key%"
    fetching: "Récupération des détails pour le ticket : %key%"
    error_not_found: "Impossible de trouver le ticket Jira avec la clé \"%key%\"."
    generated_branch: "Nom de branche généré : %branch%"
    fetching_changes: "Récupération des dernières modifications depuis origin..."
    creating_branch: "Création de la nouvelle branche : %branch%"
    success: "Branche '%branch%' créée depuis '%base%'."
    assigning: "Attribution du ticket %key% à l'utilisateur actuel..."
    assign_error: "Échec de l'attribution du ticket : %error%"
    no_transitions: "Aucune transition vers 'En cours' disponible pour le ticket %key%. Transition ignorée."
    select_transition: "Sélectionnez la transition vers 'En cours' :"
    invalid_selection: "Sélection de transition invalide."
    save_transition: "Souhaitez-vous enregistrer ce choix de transition pour le projet '%project%' ?"
    transition_saved: "Choix de transition enregistré pour le projet '%project%'."
    using_cached_transition: "Utilisation de l'ID de transition en cache : %id%"
    transition_success: "✅ Ticket %key% transitionné vers 'En cours'"
    transition_error: "Échec de la récupération des transitions : %error%"
    transition_exec_error: "Échec de l'exécution de la transition : %error%. Poursuite de la création de branche."

# Item Show Handler
  show:
    section: "Détails du ticket %key%"
    fetching: "Récupération des détails pour le ticket : %key%"
    error_not_found: "Impossible de trouver le ticket Jira avec la clé \"%key%\"."
    label_key: "Clé"
    label_title: "Titre"
    label_status: "Statut"
    label_assignee: "Assigné"
    label_type: "Type"
    label_labels: "Étiquettes"
    label_description: "Description"
    label_link: "Lien"
    label_none: "Aucun"

# Item List Handler
  list:
    section: "Récupération des tickets Jira"
    error_fetch: "Échec de la récupération des tickets : %error%"
    no_items: "Aucun ticket trouvé correspondant à vos critères."

# Project List Handler
project:
  list:
    section: "Récupération des projets Jira"
    error_fetch: "Échec de la récupération des projets : %error%"
    no_projects: "Aucun projet trouvé."

# Search Handler
search:
  section: "Recherche de tickets Jira avec JQL"
  jql_query: "Requête JQL : %jql%"
  error_search: "Échec de la recherche de tickets : %error%"
  no_results: "Aucun ticket trouvé correspondant à votre requête JQL."

# Status Handler
status:
  section: "Statut actuel"
  fetching: "Récupération du statut pour le ticket Jira : %key%"
  jira_status: "[%status%] %key% : %title%"
  jira_error: "Impossible de récupérer les détails du ticket Jira : %error%"
  jira_no_key: "Aucune clé Jira trouvée dans le nom de la branche."
  git_branch: "Sur la branche '%branch%'"
  local_changes: "Vous avez %count% modifications non commitées."
  local_clean: "Le répertoire de travail est propre."

# Please Handler
please:
  error_no_upstream: "Votre branche actuelle n'a pas de remote upstream configuré.\nPour le push initial et pour créer une Pull Request, veuillez utiliser \"stud submit\"."
  warning_force: "⚠️  Forçage avec lease..."

# Flatten Handler
flatten:
  section: "Aplatissement des commits fixup"
  error_dirty_working: "Votre répertoire de travail n'est pas propre. Veuillez commiter vos modifications avec 'stud commit' avant d'aplatir."
  warning_rewrite: "⚠️  Ceci va réécrire l'historique de vos commits. Vous devrez peut-être exécuter 'stud please' pour force-push par la suite."
  success: "✅ Tous les commits fixup! ont été fusionnés dans leurs commits cibles."
  error_rebase: "Échec du rebase : %error%"
  no_fixups: "Aucun commit fixup! ou squash! trouvé. Rien à aplatir."

# Cache Clear Handler
cache:
  clear:
    section: "Nettoyage du cache de vérification de mise à jour"
    success: "✅ Cache de vérification de mise à jour nettoyé avec succès."
    already_clear: "Le cache était déjà vide."
    error_delete: "Échec de la suppression du fichier de cache."

# Submit Handler
submit:
  section: "Soumission de Pull Request"
  error_dirty_working: "Votre répertoire de travail n'est pas propre. Veuillez commiter vos modifications avec 'stud commit' avant de soumettre."
  error_base_branch: "Impossible de créer une Pull Request depuis la branche de base."
  pushing: "Push de la branche %branch%..."
  error_push: "Échec du push. Votre branche a peut-être réécrit l'historique.\nEssayez d'exécuter 'stud please' pour forcer le push."
  finding_commit: "Recherche du premier commit logique à utiliser pour les détails de la PR..."
  fetching_jira: "Récupération du ticket Jira pour le corps de la PR : %key%"
  error_no_logical: "Impossible de trouver un commit logique sur cette branche. Impossible de créer la PR."
  error_no_jira_key: "Impossible de parser la clé Jira depuis le message de commit. Impossible de créer la PR."
  warning_jira_fetch: "Impossible de récupérer les détails du ticket Jira pour le corps de la PR : %error%\nRetour à un simple lien."
  creating: "Création de la Pull Request..."
  success_created: "✅ Pull Request créée : %url%"
  warning_no_provider: "Aucun fournisseur Git configuré pour ce projet."
  note_pr_exists: "Une Pull Request existe déjà pour cette branche."
  success_pushed: "✅ Les modifications ont été poussées vers GitHub"
  error_create_pr: "Échec de la création de la Pull Request.\nErreur : %error%"
  using_head: "Utilisation de la branche head : %head%"
  fetching_labels: "Récupération des labels du dépôt..."
  label_unknown_prompt: "Le label '%label%' n'existe pas dans le dépôt. Que souhaitez-vous faire ?"
  label_create_option: "Créer : Créer le label sur GitHub et l'ajouter à la PR"
  label_ignore_option: "Ignorer : Ignorer ce label et le retirer de la liste finale"
  label_retry_option: "Réessayer : Annuler la commande et la relancer avec une liste corrigée"
  label_creating: "Création du label '%label%'..."
  label_created: "✅ Label '%label%' créé avec succès"
  label_ignored: "Le label '%label%' sera ignoré"
  error_fetch_labels: "Échec de la récupération des labels depuis GitHub.\nErreur : %error%"
  error_create_label: "Échec de la création du label '%label%'.\nErreur : %error%"
  error_add_labels: "Échec de l'ajout des labels à la Pull Request.\nErreur : %error%"
  adding_labels: "Ajout des labels à la Pull Request..."
  updating_to_draft: "Mise à jour de la Pull Request en statut brouillon..."
  error_update_draft: "Échec de la mise à jour du statut brouillon de la Pull Request.\nErreur : %error%"

# PR Comment Handler
pr:
  comment:
    section: "Publication d'un commentaire sur la Pull Request"
    error_no_provider: "Aucun fournisseur Git configuré pour ce projet."
    error_no_input: "Aucun contenu de commentaire fourni.\nVeuillez fournir le contenu via STDIN (pipeline) ou comme argument direct.\nExemple : echo \"Texte du commentaire\" | stud pr:comment\nExemple : stud pr:comment \"Texte du commentaire\""
    error_no_pr: "Impossible de trouver une Pull Request active pour la branche actuelle."
    error_post: "Échec de la publication du commentaire sur la Pull Request.\nErreur : %error%"
    finding_pr: "Recherche de la Pull Request pour la branche : %branch%"
    posting: "Publication du commentaire sur la Pull Request #%number%..."
    success: "✅ Commentaire publié avec succès sur la Pull Request #%number%"
    using_stdin: "Lecture du commentaire depuis STDIN..."
    using_argument: "Utilisation du commentaire depuis l'argument..."

# Commit Handler
commit:
  section: "Assistant de commit conventionnel"
  staging: "Mise en staging de toutes les modifications..."
  committing: "Commit avec le message fourni..."
  committing_simple: "Commit en cours..."
  success: "Commit créé avec succès !"
  checking_logical: "Vérification du commit logique précédent..."
  found_logical: "Commit logique SHA trouvé : %sha%"
  creating_fixup: "Création d'un commit fixup pour %sha%..."
  fixup_success: "✅ Modifications enregistrées comme fixup pour le commit %sha%."
  note_no_logical: "Aucun commit logique précédent trouvé ou flag --new utilisé. Démarrage de l'assistant interactif..."
  error_no_key: "Impossible de trouver une clé Jira dans le nom de votre branche actuelle.\nVeuillez utiliser \"stud start <key>\" pour créer une branche."
  fetching_jira: "Récupération du ticket Jira : %key%"
  error_not_found: "Impossible de trouver le ticket Jira avec la clé \"%key%\"."
  jira_details: "Détails du ticket Jira :"
  jira_title: "Titre : %title%"
  jira_type: "Type : %type% -> %commit_type%"
  jira_components: "Composants : %components%"
  scope_prompt: "Portée (optionnelle)"
  scope_auto: "Portée (auto-détectée '%scope%')"
  type_prompt: "Type de commit (auto-détecté '%type%')"
  summary_prompt: "Message court (auto-rempli depuis Jira)"
  generated_message: "Message de commit généré :\n%message%"

# Update Handler
update:
  section: "Vérification des mises à jour"
  binary_path: "Chemin du binaire"
  repository: "Dépôt"
  current_version: "Version actuelle"
  latest_version: "Dernière version"
  downloading_from: "Téléchargement depuis"
  warning_no_releases: "Aucune release trouvée pour ce dépôt.\nLe dépôt n'a peut-être pas encore de releases publiées."
  error_fetch: "Échec de la récupération des informations de la dernière release.\nErreur : %error%"
  success_latest: "Vous êtes déjà sur la dernière version (%version%)."
  new_version: "Une nouvelle version (%version%) est disponible. Mise à jour..."
  error_no_phar: "Impossible de trouver l'asset stud.phar dans la dernière release.\nAssets de release : %assets%"
  error_download: "Échec du téléchargement de la nouvelle version.\nErreur : %error%"
  error_asset_id: "Échec du téléchargement de la nouvelle version.\nErreur : ID d'asset introuvable dans l'asset de release."
  error_not_writable: "Échec de la mise à jour : Le fichier n'est pas accessible en écriture.\nVeuillez ré-exécuter avec des privilèges élevés : sudo stud update"
  error_backup: "Échec de la création d'une sauvegarde de la version actuelle.\nErreur : %error%"
  error_rollback: "Échec de la mise à jour et retour en arrière effectué.\nErreur : %error%"
  error_rollback_failed: "Échec de la mise à jour et le retour en arrière a également échoué !\nErreur originale : %original_error%\nErreur de retour en arrière : %rollback_error%\nVeuillez restaurer manuellement depuis : %backup_path%"
  changelog_section: "Modifications dans la version %version%"
  breaking_changes_detected: "⚠️  Changements cassants détectés dans cette mise à jour :"
  changelog_error: "Impossible de récupérer le changelog"
  success_hash_verified: "✅ Vérification du hash réussie. Le binaire est authentique."
  error_hash_not_found: "Échec de la vérification de sécurité : Impossible de trouver le fichier de checksum dans la release.\nLe binaire ne peut pas être vérifié. Mise à jour annulée pour des raisons de sécurité."
  error_hash_calculation: "Échec de la vérification de sécurité : Impossible de calculer le hash du fichier téléchargé.\nMise à jour annulée pour des raisons de sécurité."
  error_hash_mismatch: "Échec de la vérification de sécurité : Incohérence de hash détectée !\n\nHash attendu : %expected%\nHash calculé : %calculated%\n\nLe binaire téléchargé peut être corrompu ou avoir été modifié."
  error_digest_not_found: "Échec de la vérification de sécurité : Aucun digest trouvé dans la réponse de l'API GitHub.\nLe binaire ne peut pas être vérifié."
  prompt_continue_on_verification_failure: "⚠️ Avertissement : La vérification du checksum a échoué.\nVoulez-vous continuer l'installation quand même ?"
  downloading_checksum: "Téléchargement du fichier de checksum depuis"
  checksum_download_error: "Erreur lors du téléchargement du fichier de checksum"

# Release Handler
release:
  section: "Démarrage du processus de release pour la version %version%"
  fetched: "Dernières modifications récupérées depuis origin."
  created_branch: "Branche de release créée : %branch%"
  updated_composer: "Version mise à jour dans composer.json à %version%"
  updated_lock: "composer.lock mis à jour"
  dumped_config: "Config vidée dans config/app.php"
  updated_changelog: "CHANGELOG.md mis à jour avec la version %version%"
  staged: "Modifications mises en staging."
  committed: "Incrément de version commité."
  published: "Branche de release publiée sur le remote."
  confirm_publish: "Souhaitez-vous publier la branche de release sur le remote ?"
  success: "La release %version% est prête à être déployée."

# Deploy Handler
deploy:
  section: "Démarrage du processus de déploiement"
  error_not_release: "Vous devez être sur une branche de release pour déployer."
  deployed: "Déployé sur main et tagué."
  updated_develop: "Branche develop mise à jour."
  cleaned: "Branche de release nettoyée."
  success: "Release v%version% déployée avec succès sur main. develop a été rebasé et force-pushé. Branches nettoyées."

# Table Headers
table:
  key: "Clé"
  status: "Statut"
  summary: "Résumé"
  name: "Nom"
  command: "Commande"
  alias: "Alias"
  description: "Description"

# Help Command
help:
  title: "Manuel"
  description_section: "DESCRIPTION"
  description_text: "`stud-cli` est un outil d'interface en ligne de commande conçu pour rationaliser le flux de travail quotidien d'un développeur en intégrant étroitement les éléments de travail Jira avec les opérations du dépôt Git local. Il vous guide à travers le \"chemin d'or\" de démarrage d'une tâche, de création de commits conventionnels et de préparation de votre travail pour la soumission, le tout depuis la ligne de commande."
  global_options_section: "OPTIONS GLOBALES"
  commands_section: "COMMANDES"
  global_option_help: "Afficher l'aide pour la commande donnée. Lorsqu'aucune commande n'est donnée, afficher l'aide pour la commande list."
  global_option_silent: "Ne pas afficher de message."
  global_option_quiet: "Seules les erreurs sont affichées. Toutes les autres sorties sont supprimées."
  global_option_verbose: "Augmenter la verbosité des messages : 1 pour la sortie normale, 2 pour une sortie plus verbeuse et 3 pour le debug."
  category_configuration: "Configuration"
  category_jira_information: "Informations Jira"
  category_git_workflow: "Flux de travail Git"
  category_release_commands: "Commandes de Release"
  example_prefix: "Exemple : %example%"
  command_config_init: "Assistant interactif pour configurer les détails de connexion Jira & Git."
  command_completion: "Génère des scripts d'auto-complétion pour bash ou zsh."
  command_projects_list: "Liste tous les projets Jira visibles."
  command_items_list: "Liste les éléments de travail actifs (votre tableau de bord)."
  command_items_show: "Affiche des informations détaillées pour un élément de travail."
  command_items_search: "Rechercher des issues avec JQL."
  command_items_start: "Crée une nouvelle branche git à partir d'un élément Jira."
  command_commit: "Vous guide à travers la création d'un commit conventionnel."
  command_please: "Un force-push sûr pour utilisateur avancé (force-with-lease)."
  command_flatten: "Fusionner automatiquement tous les commits fixup! dans leurs commits cibles."
  command_cache_clear: "Effacer le cache de vérification de mise à jour pour forcer une vérification de version à la prochaine commande."
  command_submit: "Pousse la branche actuelle et crée une Pull Request."
  command_pr_comment: "Publie un commentaire sur la Pull Request active. Prend en charge le piping depuis STDIN ou un argument direct."
  command_status: "Un tableau de bord rapide \"où suis-je ?\"."
  command_release: "Crée une nouvelle branche de release et incrémente la version."
  command_deploy: "Déploie la branche de release actuelle."
  command_update: "Vérifie et installe les nouvelles versions de l'outil."
  universal_help_note: "Astuce : Utilisez --help (ou -h) avec n'importe quelle commande pour voir l'aide détaillée. Par exemple : stud commit --help"
  command_specific_help_note: "Astuce : Exécutez 'stud help <commande>' pour voir l'aide détaillée d'une commande spécifique. Par exemple : stud help commit"
  command_help_title: "Aide : %command%"
  see_readme_note: "Pour plus d'informations, consultez la documentation complète dans README.md"
  command_not_found: "Texte d'aide non disponible pour la commande : %command%"
  option_all: "Lister les éléments pour tous les utilisateurs (remplace le filtre d'assigné par défaut)"
  option_project: "Filtrer les éléments par une clé de projet spécifique (par ex., PROJ)"
  option_commit_new: "Créer un nouveau commit logique au lieu d'un fixup"
  option_commit_message: "Contourner le prompteur interactif et utiliser le message fourni pour le commit"
  option_submit_draft: "Créer une Pull Request en brouillon (marquée comme \"Draft\" sur GitHub)"
  option_submit_labels: "Liste séparée par des virgules d'étiquettes à appliquer à la Pull Request. Si une étiquette n'existe pas, vous serez invité à la créer, l'ignorer ou réessayer avec une liste corrigée"
  option_update_info: "Aperçu du changelog de la dernière version disponible sans télécharger ou installer. Utile pour vérifier les changements majeurs avant la mise à jour"
  option_release_publish: "Publier la branche de release sur le dépôt distant"

